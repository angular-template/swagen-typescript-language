"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Generates a file header based on the Swagen profile and definition details.
 * @param profile Swagen profile that is being processed
 * @param definition Swagen definition that is being processed
 * @returns {string[]} A string array of the lines in the generated header
 */
function buildHeader(profile, definition) {
    const header = [
        `//------------------------------`,
        `// <auto-generated>`,
        `//     Generated using the Swagen tool`,
        `//     Generator: ${profile.generator}`,
    ];
    if (profile.mode) {
        header.push(`//     Mode: ${profile.mode}`);
    }
    header.push(`// </auto-generated>`, `//------------------------------`);
    if (definition && definition.metadata) {
        if (definition.metadata.title) {
            header.push(`// ${definition.metadata.title}`);
        }
        if (definition.metadata.description) {
            header.push(`// ${definition.metadata.description}`);
        }
        if (definition.metadata.baseUrl) {
            header.push(`// Base URL: ${definition.metadata.baseUrl}`);
        }
    }
    return header;
}
exports.buildHeader = buildHeader;
/**
 * Builds documentation comments for a given operation definition.
 * @param operation Operation definition
 * @returns {string[]} A string array of the lines in the generated doc comments.
 */
function buildOperationDocComments(operation) {
    const comments = [];
    if (operation.description) {
        comments.push(` * ${operation.description}`);
    }
    if (operation.description2) {
        comments.push(` * ${operation.description2}`);
    }
    const describedParams = (operation.parameters || []).filter(p => !!p.description);
    for (const describedParam of describedParams) {
        const dataType = getDataType(describedParam.dataType);
        comments.push(` * @param {${dataType}} ${describedParam.name} - ${describedParam.description}`);
    }
    if (comments.length > 0) {
        comments.unshift(`/**`);
        comments.push(` */`);
    }
    return comments;
}
exports.buildOperationDocComments = buildOperationDocComments;
/**
 * Returns the Typescript data type of the given property definition.
 * @param property Property definition
 * @param {string} ns Optional namespace to be prefixed for non-primitve types
 * @returns {string} The Typescript data type.
 */
function getDataType(property, ns) {
    let typeName;
    if (property.primitive) {
        typeName = getPrimitiveTypeName(property);
    }
    else if (property.complex) {
        typeName = prefixNamespace(property.complex, ns);
    }
    else if (property.enum) {
        typeName = prefixNamespace(property.enum, ns);
    }
    else {
        throw new Error(`Cannot understand type of property in definition: ${JSON.stringify(property, null, 4)}`);
    }
    return property.isArray ? typeName + '[]' : typeName;
}
exports.getDataType = getDataType;
function getPrimitiveTypeName(property) {
    switch (property.primitive) {
        case 'integer':
        case 'number':
            return 'number';
        case 'string': {
            switch (property.subType) {
                case 'date-time':
                    return 'Date';
                case 'uuid':
                    return 'string';
                case 'byte':
                    return 'number';
                default:
                    return 'string';
            }
        }
        case 'boolean':
            return 'boolean';
        case 'file':
        case 'object':
            return 'any';
        default:
            throw new Error(`Cannot translate primitive type ${JSON.stringify(property, null, 4)}`);
    }
}
function prefixNamespace(name, ns) {
    return ns ? `${ns}.${name}` : name;
}
/**
 * Creates a Typescript method signature from the given operation details.
 * @param {string} operationName Name of the operation
 * @param operation Operation definition
 * @param options Options to customize generation
 * @returns {string} A string containing the method signature
 */
function getMethodSignature(operationName, operation, options) {
    const parameters = (operation.parameters || []).reduce((accumulate, parameter) => {
        if (accumulate) {
            accumulate += ', ';
        }
        accumulate += `${parameter.name}: ${getDataType(parameter.dataType, options.modelsNs)}`;
        return accumulate;
    }, '');
    let returnType = getReturnType(operation, options);
    if (typeof options.returnTypeTransformer === 'function') {
        returnType = options.returnTypeTransformer(returnType);
    }
    const methodSig = `${operationName}(${parameters}): ${returnType}`;
    return methodSig;
}
exports.getMethodSignature = getMethodSignature;
/**
 * Returns a Typescript data type from the responses of the given operation definition.
 * @param operation Operation definition
 * @param options Options to customize return type
 * @returns {string} Typescript data type of the operation's responses.
 */
function getReturnType(operation, options) {
    if (!operation.responses) {
        return options.voidType || 'void';
    }
    for (const statusKey in operation.responses) {
        if (operation.responses.hasOwnProperty(statusKey)) {
            const statusCode = +statusKey;
            if (statusCode >= 200 && statusCode < 300 && operation.responses[statusKey].dataType) {
                return getDataType(operation.responses[statusKey].dataType, options.modelsNs);
            }
        }
    }
    return options.voidType || 'void';
}
exports.getReturnType = getReturnType;
